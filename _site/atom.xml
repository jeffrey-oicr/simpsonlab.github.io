<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Simpson Lab Blog</title>
 <link href="simpsonlab.github.io/atom.xml" rel="self"/>
 <link href="simpsonlab.github.io/"/>
 <updated>2015-05-18T18:53:26-04:00</updated>
 <id>simpsonlab.github.io</id>
 <author>
   <name>Jared Simpson</name>
   <email></email>
 </author>

 
  
 
  
 
  
   <entry>
     <title>Understanding Partial Order Alignment for Multiple Sequence Alignment</title>
     <link href="simpsonlab.github.io/2015/05/01/understanding-poa/"/>
     <updated>2015-05-01T00:00:00-04:00</updated>
     <id>simpsonlab.github.io/2015/05/01/understanding-poa</id>
     <content type="html">&lt;p&gt;Jared’s &lt;a href=&quot;https://github.com/jts/nanopolish&quot;&gt;nanopolish&lt;/a&gt; tool for
Nanopore data uses &lt;a href=&quot;http://sourceforge.net/projects/poamsa/&quot;&gt;poaV2&lt;/a&gt;,
the original partial order alignment software described in papers by
Lee, Grasso, and Sharlow &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, for
correcting the reads, following a similar approach taken by PacBio in
&lt;a href=&quot;https://github.com/PacificBiosciences/pbdagcon&quot;&gt;PBDagCon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This post gives a quick lower-level overview of the steps in the POA
algorithm, with a &lt;a href=&quot;https://github.com/ljdursi/poapy&quot;&gt;simple implementation in python&lt;/a&gt; 
to demonstrate the ideas more concretely.&lt;/p&gt;

&lt;h3 id=&quot;the-basics&quot;&gt;The Basics&lt;/h3&gt;

&lt;p&gt;The insight of the first POA paper was that “flattening” of
the alignment of sequences leads to meaningless artifacts that, while
largely harmless for pairwise alignments or even multiple alignments
of strongly conserved sequences, causes problems with more general
multiple alignments.  For instance, consider the following sequences:&lt;/p&gt;

&lt;pre&gt;
&amp;gt;seq1
CCGCTTTTCCGC
&amp;gt;seq2
CCGCAAAACCGC
&lt;/pre&gt;

&lt;p&gt;There is ambiguity in selecting a single, best alignment between this
pair of sequences; for instance below are 4 of 2&lt;sup&gt;8&lt;/sup&gt; = 256 nearly equivalent
ways of expressing this pairwise alignment. The best alignment will
depend on the particular gap-scoring scheme used.&lt;/p&gt;

&lt;pre&gt;
CCGC----TTTTCGCG   CCGCTTTT----CCGC  CCGC-TT-TT--CGCG   CCGC-T-T-T-TCCGC
CCGCAAAA----CGCG   CCGC----AAAACCGC  CCGCA--A--AACCGC   CCGCA-A-A-A-CCGC
&lt;/pre&gt;

&lt;p&gt;While for a pairwise alignment this is comparatively harmless, as
additional sequences are added to form a multiple sequence alignment
(MSA), the choice between these ambiguities begin to distort the eventual
result. What we would like is to consider not necessarily a single linear
layout, but something that can express more unambiguously “one
sequence inserts a run of A, and the other of T”. And a natural way
to view that is with a graph:&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis/3.11.0/vis.min.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;mynetwork&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
var nodes = [
    {id:0, label: &quot;C&quot;, allowedToMoveX: false, x: 0, y: 0 , allowedToMoveY: true }, {id:1, label: &quot;C&quot;, allowedToMoveX: false, x: 150, y: 0 , allowedToMoveY: true },
    {id:2, label: &quot;G&quot;, allowedToMoveX: false, x: 300, y: 0 , allowedToMoveY: true }, {id:3, label: &quot;C&quot;, allowedToMoveX: false, x: 450, y: 0 , allowedToMoveY: true },
    {id:12, label: &quot;A&quot;, allowedToMoveX: false, x: 600, y: 0 , allowedToMoveY: true }, {id:4, label: &quot;T&quot;},
    {id:13, label: &quot;A&quot;, allowedToMoveX: false, x: 750, y: 0 , allowedToMoveY: true }, {id:5, label: &quot;T&quot;},
    {id:14, label: &quot;A&quot;, allowedToMoveX: false, x: 900, y: 0 , allowedToMoveY: true }, {id:6, label: &quot;T&quot;},
    {id:15, label: &quot;A&quot;, allowedToMoveX: false, x: 1050, y: 0 , allowedToMoveY: true }, {id:7, label: &quot;T&quot;},
    {id:8, label: &quot;C&quot;, allowedToMoveX: false, x: 1200, y: 0 , allowedToMoveY: true }, {id:9, label: &quot;C&quot;, allowedToMoveX: false, x: 1350, y: 0 , allowedToMoveY: true },
    {id:10, label: &quot;G&quot;, allowedToMoveX: false, x: 1500, y: 0 , allowedToMoveY: true }, {id:11, label: &quot;C&quot;, allowedToMoveX: false, x: 1650, y: 0 , allowedToMoveY: true }
];
 
var edges = [
    {from: 0, to: 1, value: 3}, {from: 1, to: 2, value: 3}, {from: 2, to: 3, value: 3}, {from: 3, to: 12, value: 2}, {from: 3, to: 4, value: 2},
    {from: 12, to: 13, value: 2}, {from: 4, to: 5, value: 2}, {from: 13, to: 14, value: 2}, {from: 5, to: 6, value: 2}, {from: 14, to: 15, value: 2},
    {from: 6, to: 7, value: 2}, {from: 15, to: 8, value: 2}, {from: 7, to: 8, value: 2}, {from: 8, to: 9, value: 3}, {from: 9, to: 10, value: 3},
    {from: 10, to: 11, value: 3}
];

  var container = document.getElementById(&#39;mynetwork&#39;);
  var data= { nodes: nodes, edges: edges, };
  var options = { width: &#39;100%&#39;, height: &#39;200px&#39; };
  var network = new vis.Network(container, data, options);
&lt;/script&gt;

&lt;p&gt;The partial order alignment graph differs from the alignment strings
in that a given base can have multiple predecessors (&lt;em&gt;eg&lt;/em&gt;, the &lt;code&gt;C&lt;/code&gt;
after the fork being preceeded by both a string of &lt;code&gt;A&lt;/code&gt;s and of &lt;code&gt;T&lt;/code&gt;s)
or successors (&lt;em&gt;eg&lt;/em&gt;, the &lt;code&gt;C&lt;/code&gt; before the fork).  But it is similar to
the alignment strings in that there is a directional order imposed,
both in the sense that each node has (zero or more) predecessors and
(zero or more) successors, but also that no repetition, or doubling
back, is allowed; the graph is constrained to be a &lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_acyclic_graph&quot;&gt;Directed, Acyclic
Graph&lt;/a&gt; (DAG).&lt;/p&gt;

&lt;p&gt;Both repeats and re-orderings can be biologically relevant, and various
generalizations of alignment have allowed this &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;.
This greatly generalizes the problem, moving it closer to assembly.
For the purposes of error correction in nanopolish, that additional
generalization is not needed.&lt;/p&gt;

&lt;h3 id=&quot;smith-waterman&quot;&gt;Smith-Waterman&lt;/h3&gt;

&lt;p&gt;To consider how alignment to a graph works, let ’s remind ourselves of
how we perform alignment on sequences.&lt;/p&gt;

&lt;p&gt;In the
&lt;a href=&quot;http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm&quot;&gt;Needleman-Wunsch&lt;/a&gt;
algorithm and its variants, we consider two cursors - one on a base in
each sequence.  For each pair of cursor positions in turn, we consider
the question of “what is the best sequence of alignments and insertions
that could lead to this position in the alignment”.  Because the globally
optimal path must be made from locally optimal “moves” (that is, the
“principle of optimality” holds for this problem), this reduces to finding
out which of the three possible moves that would advance the cursors to
this position to choose from:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Both cursors having advanced, aligning (matching) these two bases;&lt;/li&gt;
  &lt;li&gt;Cursor 1 had advanced while cursor 2 remained fixed, inserting that base from sequence 1 into the alignment&lt;/li&gt;
  &lt;li&gt;Vice versa, with cursor 2 advancing and cursor 1 staying fixed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A familiar diagram follows below; of those three possible moves, we take the
running scores from each of those previous positions, add the score
corresponding to the move, and set the score of the current position.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/poa/sw-dynamicprogramming.png&quot; alt=&quot;Dynamic programming for string-string alignment&quot; title=&quot;Dynamic programming for string-string alignment&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can calculate the scores for pairs of positions in any order we like
– along rows of the matrix, columns, or minor diagonals –
as long as for any position we calculate, the scores for the previous 
positions we need have already been calculated.&lt;/p&gt;

&lt;h3 id=&quot;string-to-graph-alignment&quot;&gt;String to Graph Alignment&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/poa/poa-dynamicprogramming.png&quot; alt=&quot;Dynamic programming for graph-string alignment&quot; title=&quot;Dynamic programming for graph-string alignment&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Aligning a sequence to a DAG introduces suprisingly little complexity to the
dynamic programming problem; the clever diagram in the POA paper with a dynamic
programming matrix with 3D “bumps” may have had the unintended consequence of
making it look more complicated than it is.&lt;/p&gt;

&lt;p&gt;The primary difference for the purposes of dynamic programming is
that while a base in a sequence has exactly one predecessor, a base
in a graph can have two or more.  Thus, the cursor may have come from
one of several previous locations for the same (graph) Insert or Align
moves being considered; and thus those scores must be considered too in
determining the best previous position.  (Note that insertions from the
sequence are unchanged).&lt;/p&gt;

&lt;p&gt;So, to reiterate: the only difference deep inside the dynamic programming
loop is that multiple previous scores (and any associated gap-open
information) must be considered for insertions or alignments of the
graph base.  This is implemented by a loop over predecessors for the current
base, and all else remains the same.&lt;/p&gt;

&lt;h3 id=&quot;topological-sort&quot;&gt;Topological Sort&lt;/h3&gt;

&lt;p&gt;There is one step that has to happen &lt;em&gt;before&lt;/em&gt; that dynamic programming loop,
however.&lt;/p&gt;

&lt;p&gt;When aligning two sequences, one could choose an order to loop over the
sequence indices before hand so that, for any new position being calculated,
the necessary previous scores would already be ready.&lt;/p&gt;

&lt;p&gt;The nodes in the graph, however, do not have such a useful intrinsic
order.  If the nodes are considered in the order they are added, for
instance, then the newest nodes inserted with a new sequence –
which may have been inserted as predecessors of nodes that had been
inserted earlier – will not have been already scored when their
successor begins its calculation.&lt;/p&gt;

&lt;p&gt;The answer is to use a &lt;a href=&quot;http://en.wikipedia.org/wiki/Topological_sorting&quot;&gt;Topological Sort&lt;/a&gt; to generate an
ordering of nodes in which every node is guaranteed to follow all of
its predecessors.  This is always possible for a directed graph as long
as there are no cycles, and indeed there can be many such orderings.
Topological sorts are how &lt;code&gt;make&lt;/code&gt; and similar tools decide in which order 
to perform tasks in a workflow, and how many&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; spreadsheet programs decide 
if cells need to be updated.&lt;/p&gt;

&lt;p&gt;There are two main classes of algorithms for performing topological sorts; the
algorithm of Kahn (1962), and a repeated depth-first search.  Either serves
perfectly well for the dynamic programming problem.&lt;/p&gt;

&lt;p&gt;So to align a sequence to a graph, the steps are simply:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Perform a topological sort if the graph has been updated&lt;/li&gt;
  &lt;li&gt;Do the dynamic programming step as usual, with:
    &lt;ul&gt;
      &lt;li&gt;The graph nodes visited in the order of the topological sort, and&lt;/li&gt;
      &lt;li&gt;Considering all valid predecessors for align/insert moves.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;insertion-of-aligned-sequence&quot;&gt;Insertion of aligned sequence&lt;/h3&gt;

&lt;p&gt;Consider that we have a graph that so far only contains the sequence &lt;code&gt;CGCTTAT&lt;/code&gt;,
and our dynamic programming calculation aligning the sequence &lt;code&gt;CGATTACG&lt;/code&gt; has
given us an alignment that looks like this:&lt;/p&gt;

&lt;pre&gt;
CGATTACG
||.|||.
CGCTTAT-
&lt;/pre&gt;

&lt;p&gt;That is, for each base in the sequence, it is paired (either as match or
mismatch) with a base in the graph, or it is inserted.&lt;/p&gt;

&lt;p&gt;We expect inserting the new sequence into the graph to give us something like:&lt;/p&gt;

&lt;div id=&quot;mynetwork2&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  // create a network
var nodes = [
    {id:0, label: &quot;C&quot;, allowedToMoveX: false, x: 0, y: 0 , allowedToMoveY: true }, {id:1, label: &quot;G&quot;, allowedToMoveX: false, x: 150, y: 0 , allowedToMoveY: true },
    {id:8, label: &quot;C&quot;, allowedToMoveX: false, x: 300, y: 0 , allowedToMoveY: true }, {id:2, label: &quot;A&quot;},
    {id:3, label: &quot;T&quot;, allowedToMoveX: false, x: 450, y: 0 , allowedToMoveY: true }, {id:4, label: &quot;T&quot;, allowedToMoveX: false, x: 600, y: 0 , allowedToMoveY: true },
    {id:5, label: &quot;A&quot;, allowedToMoveX: false, x: 750, y: 0 , allowedToMoveY: true }, {id:9, label: &quot;T&quot;},
    {id:6, label: &quot;C&quot;, allowedToMoveX: false, x: 900, y: 0 , allowedToMoveY: true }, {id:7, label: &quot;G&quot;, allowedToMoveX: false, x: 1050, y: 0 , allowedToMoveY: true }
];
 
var edges = [
    {from: 0, to: 1, value: 3}, {from: 1, to: 8, value: 2}, {from: 1, to: 2, value: 2},
    {from: 8, to: 3, value: 2}, {from: 2, to: 3, value: 2}, {from: 2, to: 8, value: 1, style: &quot;dash-line&quot;},
    {from: 3, to: 4, value: 3}, {from: 4, to: 5, value: 3}, {from: 5, to: 9, value: 2},
    {from: 5, to: 6, value: 2}, {from: 6, to: 7, value: 2}, {from: 6, to: 9, value: 1, style: &quot;dash-line&quot;}
];

  var container = document.getElementById(&#39;mynetwork2&#39;);
  var data= { nodes: nodes, edges: edges, };
  var options = { width: &#39;100%&#39;, height: &#39;200px&#39; };
  var network = new vis.Network(container, data, options);
&lt;/script&gt;

&lt;p&gt;Here we see for the first time two types of edges; bold, directed edges
(with directions not shown, but left-to-right), indicating
predecessor/successor; and dashed lines, indicating that (say) the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;
that are three bases from the start are aligned to each other, but are
mismatches; similarly with the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; towards the end.&lt;/p&gt;

&lt;p&gt;We keep track of both the predecessor/successor nodes and all ‘aligned-to’
nodes.  We walk along the sequence we are inserting and its calculated
alignment.  We insert nodes in the sequence if they are not aligned to
anything, or none of the nodes that it directly or indirectly aligns to have
the same base; otherwise, we re-use that node and simply add new edges to it if
necessary.&lt;/p&gt;

&lt;p&gt;In more detail, the steps we take are as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A new “starting point” for this sequence is created in the graph.&lt;/li&gt;
  &lt;li&gt;The previous position is set to this starting point.&lt;/li&gt;
  &lt;li&gt;For each sequence base in the calculated alignment,
    &lt;ul&gt;
      &lt;li&gt;If the current base is not aligned to a node in the graph, or if it is but neither the node nor any node &lt;em&gt;it&lt;/em&gt; is aligned to has the same base,
        &lt;ul&gt;
          &lt;li&gt;A new node is created with the sequence base, and is selected as the current node&lt;/li&gt;
          &lt;li&gt;This new node is aligned to the aligned node if any, and all of the “aligned-to” nodes are updated to align to this one.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Otherwise,
        &lt;ul&gt;
          &lt;li&gt;That node with the same base is selected as the current node&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;If one does not already exist, a new edge is added from the previous position to the current node&lt;/li&gt;
      &lt;li&gt;That edge has the current sequence label added to it; the number of labels on the edge correspond to the number of sequences that include that edge and those two nodes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fusing nodes whenever possible ensures that information about a motif that
several times in several sequences in a similar location is not obscured
by corresponding to several paths through the graph; It also increases
the runtime of the algorithm by limiting the number of nodes and edges that
need to be considered.&lt;/p&gt;

&lt;p&gt;Note that one can always reconstruct any individual sequence inserted into the
graph by looking up its starting point, and following edges labelled with the
corresponding label through the graph.&lt;/p&gt;

&lt;p&gt;Once an aligned sequence is inserted, a new topological sort of the nodes is
generated, and another alignment can be perfomed.&lt;/p&gt;

&lt;h3 id=&quot;consensus-paths&quot;&gt;Consensus paths&lt;/h3&gt;

&lt;p&gt;Now that you have all of your sequences in the graph, how do you get things
like a consensus sequence out of it?  This is the topic of a paper&lt;sup id=&quot;fnref:2:1&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; separate
from the first one.&lt;/p&gt;

&lt;p&gt;Finding the single best-supported traversal through the graph is relatively
straightforward.  In fact, this is again a dynamic programming problem; one
sets the scores of all nodes to zero, and then marches through the graph node
by node.  At each node, one chooses the “best” edge into that node – the
one with the most sequences including it – and sets the score to be 
the edge weight plus the score of the node pointed to; and in case of a tie
between edges, one chooses the one pointing to the highest-scoring node.&lt;/p&gt;

&lt;p&gt;The highest score and the edges chosen gives you a maximum-weighted path
through the graph.  As is pointed out in the consensus paper, this is
a maximum-likelihood path if the edge weights correspond to the probabilities
that the edge is followed.&lt;/p&gt;

&lt;p&gt;However, there may well be multiple consensus features in the alignment that
one wishes to extract; a feature seen by multiple but still a minority of
sequences.  The approach to finding remaining consenses is necessarily somewhat
heuristic, and comprises the bulk of the consensus paper.&lt;/p&gt;

&lt;p&gt;The basic idea is to somehow remove or downweight the edges that
correspond to the already-extracted consenses, and repeat the procedure
to find additional features.  The steps recommended in the consensus paper are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Identify sequences that correspond to the consensus just identified; by (&lt;em&gt;eg&lt;/em&gt;) fraction of their bases/edges included, possibly with other requirements&lt;/li&gt;
  &lt;li&gt;For edges corresponding to those sequences, reduce the weight corresponding to those sequences, possibly to zero&lt;/li&gt;
  &lt;li&gt;Rerun the consensus algorithm.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the simple implementation we use to demonstrate these ideas, we simply
choose all (remaining) sequences that have a majority of their bases
represented in the current consensus sequence, remove the corresponding weight
of those edges entirely, and repeat until no further sequences remain or no
significant consensus sequence is found.&lt;/p&gt;

&lt;p&gt;The consensus paper identifies a particular corner case where a consensus
sequence might terminate early; we allow this to happen.&lt;/p&gt;

&lt;h3 id=&quot;alignment-strings&quot;&gt;Alignment strings&lt;/h3&gt;

&lt;p&gt;Finally, to communicate the alignment results, it can still be useful
to generate a “flattened” alignment of the input and consensus sequences.&lt;/p&gt;

&lt;p&gt;This is again fairly straightforwardly done once the graph is topologically
sorted.  Each node in the graph, in topological order, is assigned a column
in the final table to be generated, with rings of nodes that are aligned to
each other assigned to the same column, and nodes that are not aligned to any
others getting their own column. Then the bases are filled in, with each 
sequence (including the consensus sequences) getting their own row.&lt;/p&gt;

&lt;p&gt;Because we are assigning columns to the nodes in topologically-sorted order,
the method used to generate the (non-unique) topological sort affects how
the alignments look as alignment strings, even if they are all functionally
identical.  Kahn sorting tends to interleave the results of sequences, whereas
depth-first-search necessarily visits long strings of runs in order.  DFS
then generates better looking alignment strings, so we use that approach
in the implementation below.&lt;/p&gt;

&lt;h3 id=&quot;simple-implementation&quot;&gt;Simple Implementation&lt;/h3&gt;

&lt;p&gt;A simple but fully functional Python implementation of the algorithms
described above &lt;a href=&quot;https://github.com/ljdursi/poapy&quot;&gt;can be found here&lt;/a&gt;.
For the alignment stage, two implementations are given; one
that is quite simple to follow but is very slow; and another
that is significantly faster, but may require a little more careful
reading, as it uses numpy vectorization to improve performance.&lt;/p&gt;

&lt;p&gt;Even the faster implementation is still slow – about 10 times slower
than the &lt;a href=&quot;http://sourceforge.net/projects/poamsa/&quot;&gt;poaV2&lt;/a&gt; code written
in C as distributed, or closer to 20 if poaV2 is compiled with &lt;code&gt;-O3&lt;/code&gt;
– but is nonetheless useable for small problems.&lt;/p&gt;

&lt;p&gt;The simple implementation above can generate HTML with an interactive
graph visualization to explore the final partial order graph; the
visualization works particularly well on browsers with a high-performance
javascript implementation, but stops being useful for graphs with more
than a thousand nodes or so.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Partial order alignment is a powerful technique that results in a
graph containing rich information concerning the structure of the
aligned sequences, but lacks the amount of online documentation and
easy-to-explore implementations of some other methods; we hope this
helps introduce a broader audience to a more in-depth understanding
of the method.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://bioinformatics.oxfordjournals.org/content/18/3/452.short&quot;&gt;Multiple sequence alignment using partial order graphs&lt;/a&gt; (2002) by Lee, Grasso, and Sharlow &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://bioinformatics.oxfordjournals.org/content/19/8/999.short&quot;&gt;Generating consensus sequences from partial order multiple sequence alignment graphs&lt;/a&gt; (2003) by Lee &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:2:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://bioinformatics.oxfordjournals.org/content/20/10/1546.short&quot;&gt;Combining partial order alignment and progressive multiple sequence alignment increases alignment speed and scalability to very large alignment problems &lt;/a&gt; (2004), Grasso and Lee &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://nar.oxfordjournals.org/content/34/20/5932.short&quot;&gt;Multiple alignment of protein sequences with repeats and rearrangements&lt;/a&gt; (2006) Phouong &lt;em&gt;et al.&lt;/em&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://genome.cshlp.org/content/21/9/1512.short&quot;&gt;Cactus: Algorithms for genome multiple sequence alignment&lt;/a&gt; (2011) Paten &lt;em&gt;et al.&lt;/em&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;Later versions of excel actually allow circular dependencies in cell calculations.&lt;sup id=&quot;fnref:6:1&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
   </entry>
  
 
  
   <entry>
     <title>Aligning Nanopore Events to a Reference</title>
     <link href="simpsonlab.github.io/2015/04/08/eventalign/"/>
     <updated>2015-04-08T00:00:00-04:00</updated>
     <id>simpsonlab.github.io/2015/04/08/eventalign</id>
     <content type="html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This post describes a new module I added to our &lt;a href=&quot;https://github.com/jts/nanopolish&quot;&gt;nanopolish&lt;/a&gt; software package that aligns the signal data emitted by a nanopore to a reference genome. This is in contrast to most approaches which align two DNA sequences to each other (for example a base-called read and a reference genome). To make sense of what aligning signal data to a reference genome means, I will describe at a high level my model of how nanopore sequencing works. For a more detailed and technical description, see the supplement of our &lt;a href=&quot;http://biorxiv.org/content/early/2015/03/11/015552&quot;&gt;preprint&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;nanopore-sequencing&quot;&gt;Nanopore Sequencing&lt;/h2&gt;

&lt;p&gt;A nanopore sequencer threads a single strand of DNA through a pore embedded in a membrane. The pore allows electric current to flow from one side of the membrane to the other. As DNA transits this pore it partially blocks the flow of current, which is measured by the instrument. In Oxford Nanopore’s MinION system the measured current depends on the 5-mer that resides in the pore when the measurements are taken.&lt;/p&gt;

&lt;p&gt;The MinION samples the current thousands of times per second; as 5-mers slide though the pore they should be observed in multiple samples. The MinION’s event detection software processes these samples and tries to detect points where the current level changes. These jumps indicate a new 5-mer resides in the pore. To help illustrate this I’ve reproduced a figure from our preprint below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simulation.svg&quot; alt=&quot;simulation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is a simulation from an idealized nanopore sequencing process. The black dots represent the sampled current and the red lines indicate contiguous segments that make up the detected &lt;em&gt;events&lt;/em&gt;. For example the mean current was around 60 picoamps, plus a bit of noise, for the first 0.5s. The current then dropped to 40 pA for 0.1s before jumping to 52 pA and so on.&lt;/p&gt;

&lt;p&gt;The event detection software writes the events to an HDF5 file. The raw kHz samples are typically not stored as the output files would be impractically large. Here’s the table of events for this simulation:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;event index&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;mean (pA)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;length (s)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60.3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.521&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;40.6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.112&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;52.2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.356&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;54.1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.051&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;61.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.291&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;72.7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.015&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;49.4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.141&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To help translate events into a DNA sequence, Oxford Nanopore provides a &lt;em&gt;pore model&lt;/em&gt; which describes the expected current signal for each 5-mer. The pore model is a set of 1024 normal distributions - an example might look like this:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5-mer&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\mu_k&lt;/script&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\sigma_k&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AAAAA&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;53.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AAAAC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;54.2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;…&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;…&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TTTTG&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;65.3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TTTTT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;67.1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This indicates that the measured current is expected to be drawn from &lt;script type=&quot;math/tex&quot;&gt;\mathcal{N}(53.5, 1.3^2)&lt;/script&gt; when AAAAA is in the pore and so on.&lt;/p&gt;

&lt;h2 id=&quot;inferring-bases-from-events&quot;&gt;Inferring Bases from Events&lt;/h2&gt;

&lt;p&gt;Using the pore model and the observed data we can solve a number of inference problems. For example we can infer the sequence of nucleotides that passed through the pore. This is the base calling problem. We can also infer the sequence of the genome given a set of overlapping reads. This is the consensus problem, which we addressed in our paper.&lt;/p&gt;

&lt;p&gt;These inference problems are complicated by two important factors. First, the normal distributions for 5-mers overlap. There are 1024 different 5-mers but the signals typically range from about 40-70 pA. This can make it difficult to infer which 5-mer generated a particular event. This is partially mitigated by the structure of the data; a solution must respect the overlap between 5-mers so a position that is difficult to resolve may become clear when we look at subsequent events. Second, event detection is performed in real time and inevitably makes errors. Some events may not be detected if they are too short or if the signals for adjacent 5-mers of the DNA strand are very similar. The extreme case for the latter situation occurs when sequencing through long homopolymers - here we do not expect a detectable change in current. The opposite problem occurs as well. The event detector may split what should be a single event into multiple events due to noise in the system that looks like a change in current. Handling these artefacts is key to accurately inferring the DNA sequence that generated the events.&lt;/p&gt;

&lt;h2 id=&quot;aligning-events-to-a-reference&quot;&gt;Aligning Events to a Reference&lt;/h2&gt;

&lt;p&gt;The hidden Markov model we designed for the consensus problem had 5-mers of a proposed consensus sequence as the backbone of the HMM, with additional states and transitions to handle the skipping/splitting artefacts. In our preprint we used this HMM to calculate a consensus sequence from a set of reads. If we make a reference genome the backbone of the HMM, we can use it to align events to the reference.&lt;/p&gt;

&lt;p&gt;The new &lt;code&gt;eventalign&lt;/code&gt; module of &lt;code&gt;nanopolish&lt;/code&gt; exposes this functionality as a command line tool.  This program takes in a set of nanopore reads aligned in base-space to a reference sequence (or draft genome assembly) and re-aligns the reads in event space.&lt;/p&gt;

&lt;p&gt;The pipeline uses &lt;code&gt;bwa mem&lt;/code&gt; alignments as a guide. We start with a normal bwa workflow:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bwa mem -x ont2d -t 8 ecoli_k12.fasta reads.fa | samtools view -Sb - | samtools sort - alignments.sorted
samtools index alignments.sorted.bam
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then realign in event space                                                   using nanopolish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nanopolish eventalign -r reads.fa -b alignments.sorted.bam -g ecoli_k12.fasta &quot;gi|556503834|ref|NC_000913.3|:10000-20000&quot; &amp;gt; eventalign.tsv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;contig                         position  reference_kmer  read_index  strand  event_index  event_level_mean  event_length  model_kmer  model_mean  model_stdv
gi|556503834|ref|NC_000913.3|  10000     ATTGC           1           c       27470        50.57             0.022         ATTGC       50.58       1.02
gi|556503834|ref|NC_000913.3|  10001     TTGCG           1           c       27471        52.31             0.023         TTGCG       51.68       0.73
gi|556503834|ref|NC_000913.3|  10001     TTGCG           1           c       27472        53.05             0.056         TTGCG       51.68       0.73
gi|556503834|ref|NC_000913.3|  10001     TTGCG           1           c       27473        54.56             0.011         TTGCG       51.68       0.73
gi|556503834|ref|NC_000913.3|  10002     TGCGC           1           c       27474        65.56             0.012         TGCGC       66.96       2.91
gi|556503834|ref|NC_000913.3|  10002     TGCGC           1           c       27475        69.97             0.071         TGCGC       66.96       2.91
gi|556503834|ref|NC_000913.3|  10003     GCGCT           1           c       27476        67.11             0.017         GCGCT       68.08       2.20
gi|556503834|ref|NC_000913.3|  10004     CGCTG           1           c       27477        69.47             0.052         CGCTG       69.84       1.89
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the complement strand (c) of a 2D Nanopore read from Nick’s &lt;a href=&quot;http://www.gigasciencejournal.com/content/3/1/22&quot;&gt;E. coli data&lt;/a&gt; aligned to E. coli K12. The first event listed (event 27470) had a measured current level of 50.57 pA. It aligns to the reference 5-mer ATTGC at position 10,000 of the reference genome. The pore model indicates that events measured for 5-mer ATTGC should come from &lt;script type=&quot;math/tex&quot;&gt;\mathcal{N}(50.58, 1.02^2)&lt;/script&gt;, which matches the observed data very well. The next 3 events (27471, 27472, 27473) are all aligned to the same reference 5-mer (TTGCG) indicating that the event detector erroneously called 3 events where only one should have been emitted. Note that the current for these 3 events are all plausibly drawn from the expected distribution &lt;script type=&quot;math/tex&quot;&gt;\mathcal{N}(51.68, 0.73^2)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;This output has one row for every event. If a reference 5-mer was skipped, there will be a gap in the output where no signal was observed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gi|556503834|ref|NC_000913.3|   10009   GCACC   1       c       27489   67.52   0.028   GCACC   66.83   2.46
gi|556503834|ref|NC_000913.3|   10011   ACCGC   1       c       27490   65.17   0.012   ACCGC   65.03   1.92
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we did not observe an event for the 5-mer at position 10010.&lt;/p&gt;

&lt;p&gt;This module will hopefully make it easier to work with signal-level nanopore data, and help the development of improved models. The &lt;code&gt;eventalign&lt;/code&gt; module can be found in the latest version of &lt;a href=&quot;https://github.com/jts/nanopolish&quot;&gt;nanopolish&lt;/a&gt;.&lt;/p&gt;
</content>
   </entry>
  
 
  
   <entry>
     <title>Nanopolish v0.2.0</title>
     <link href="simpsonlab.github.io/2015/03/30/optimizing-hmm/"/>
     <updated>2015-03-30T00:00:00-04:00</updated>
     <id>simpsonlab.github.io/2015/03/30/optimizing-hmm</id>
     <content type="html">&lt;p&gt;This post describes changes I have made to &lt;a href=&quot;https://github.com/jts/nanopolish&quot;&gt;nanopolish&lt;/a&gt;, our HMM-based consensus caller for Oxford Nanopore data. This post can be thought of as a long changelog with background and rationale.&lt;/p&gt;

&lt;h2 id=&quot;background-and-history&quot;&gt;Background and History&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://nickloman.github.io/&quot;&gt;Nick Loman&lt;/a&gt;, Josh Quick and I started working on nanpore assembly at a hackathon at the Newton Institute in Cambridge. Our initial goal was pretty simple; we wanted to see if we could run &lt;a href=&quot;https://github.com/thegenemyers/DALIGNER&quot;&gt;DALIGNER&lt;/a&gt; on nanopore data and devise a way to error correct the reads. After a lot of tinkering and “proper bioinformatics” as Nick put it (converting file formats) we were able to run &lt;a href=&quot;http://sourceforge.net/projects/poamsa/&quot;&gt;poa&lt;/a&gt; on the overlapping reads that DALIGNER found. Taking poa’s consensus sequence as the error corrected read improved identity to around 92-93%. Nick was able to get &lt;a href=&quot;http://wgs-assembler.sourceforge.net/wiki/index.php?title=Main_Page&quot;&gt;Celera Assembler&lt;/a&gt; running on the corrected reads and our assembly became progressively better as Nick and Josh added more data.&lt;/p&gt;

&lt;p&gt;Once Nick got a single-contig assembly out of Celera Assembler we turned our attention to improving the accuracy of the final assembly. The consensus sequence that Celera Assembler called off the corrected reads had accuracy of about 98%. We knew that by working with the base-called reads, rather than the raw signal data emitted by the nanopore, we were losing a lot of information. During the winter holidays I started to write code that would use the raw current signal to call a new consensus. My initial exploratory code was in Python as the &lt;a href=&quot;https://github.com/arq5x/poretools&quot;&gt;poretools&lt;/a&gt; package gave convenient access to the raw signal data encoded in ONT’s FAST5 files. I wrote a quick hidden Markov model in Python to calculate the probability of observing a sequence of nanopore signals given an arbitrary sequence. I immediately realized my Python HMM would be far too slow to run on even a bacterial genome so I decided the core algorithms would have to be written in C or C++.&lt;/p&gt;

&lt;p&gt;I asked on twitter the best way to call out to a C++ library from Python and received many helpful replies (h/t to Titus Brown, Michael Crusoe and others). I settled on using &lt;a href=&quot;https://docs.python.org/2/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; as this bridge between the Python frontend/poretools and the HMM in C++. I was surprised at how easy ctypes makes this - I had Python talking to a prototype C++ library in under an hour. This hybrid Python/C++ solution was just fast enough to make model development and testing possible. We spent the next month or so revising the probabilistic model of the data, developing algorithms to propose candidate consensus sequences and testing them on our E. coli data. Once the model settled we ran it on the single-contig assembly which took a few days running in parallel on Nick’s server. We wrote up a &lt;a href=&quot;http://biorxiv.org/content/early/2015/03/11/015552&quot;&gt;preprint&lt;/a&gt; describing this work and posted it on BioRxiv.&lt;/p&gt;

&lt;h2 id=&quot;improving-the-design&quot;&gt;Improving the design&lt;/h2&gt;

&lt;p&gt;I was not satisfied with the Python/C++ hybrid design. I am sensitive to installation issues when releasing software as I have found that installing dependencies is a major source of problems for the user (although great projects like &lt;a href=&quot;https://github.com/Homebrew/homebrew-science&quot;&gt;homebrew-science&lt;/a&gt; are helping a lot here). I admire Heng Li’s software where one usually just needs to run &lt;code&gt;git clone&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; to build the program. The initial version of nanopolish was far from this ideal as it depended on eight Python libraries that needed to be installed with &lt;code&gt;pip&lt;/code&gt;. When moving between my local development version and Nick’s server I realized that installing these dependencies often failed. With this in mind I decided to rewrite the Python frontend in C++. To do this, I crucially needed a replacement for poretools which I used to access the raw data. Matei David in my group volunteered to help and wrote an excellent, intuitive C++ &lt;a href=&quot;https://github.com/mateidavid/fast5&quot;&gt;library&lt;/a&gt; for parsing ONT’s FAST5 files.&lt;/p&gt;

&lt;p&gt;There were additional benefits to this rewrite. In the Python version I again used poa to compute an initial multiple alignment and used this to seed the HMM realignment. In the C++ version I discarded this step, removing another dependency, by calculating the initial alignment directly from the BAM file using &lt;a href=&quot;https://github.com/samtools/htslib&quot;&gt;htslib&lt;/a&gt;. This simplification, along with the much faster parsing of the FAST5 files provided by Matei’s library, reduced startup time from a few minutes to a few seconds. This has helped me iterate on the code much faster during development.&lt;/p&gt;

&lt;h2 id=&quot;improving-hmm-efficiency&quot;&gt;Improving HMM efficiency&lt;/h2&gt;

&lt;p&gt;Despite writing the HMM in C++ the first version of nanopolish was very slow. After the Python to C++ rewrite I focused on improving run time. During development I use a lightweight header-only &lt;a href=&quot;https://github.com/jts/sga/blob/master/src/Util/Profiler.h&quot;&gt;profiler&lt;/a&gt; to keep track of where time is being spent in my program. As expected over 90% of the time was spent running the forward algorithm on the hidden Markov model. I used the amazing &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;perf&lt;/a&gt; kernel profiler to explore this further. &lt;code&gt;perf&lt;/code&gt; indicated that most time was in the &lt;script type=&quot;math/tex&quot;&gt;\log()&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\exp()&lt;/script&gt; functions. The forward algorithm on HMMs requires summing log-transformed probabilities. The naive way, &lt;script type=&quot;math/tex&quot;&gt;c = \log(\exp(a) + \exp(b))&lt;/script&gt;, requires two calls to &lt;script type=&quot;math/tex&quot;&gt;\exp&lt;/script&gt; and one call to &lt;script type=&quot;math/tex&quot;&gt;\log&lt;/script&gt; for every state/emission pair in the HMM. This is very slow and the subject of an entire section in the classic Biological Sequence Analysis text. I remembered reading Sean Eddy’s &lt;a href=&quot;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002195&quot;&gt;paper&lt;/a&gt; on accelerating HMMER3. In this paper Sean describes how the calculation can be improved by using the transformation &lt;script type=&quot;math/tex&quot;&gt;c = a + \log(1 + \exp(b - a))&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;a \geq b&lt;/script&gt;. On the surface this would only save a single call to &lt;script type=&quot;math/tex&quot;&gt;\exp&lt;/script&gt; but Sean goes further by using a table indexed by &lt;script type=&quot;math/tex&quot;&gt;b - a&lt;/script&gt; to cache &lt;script type=&quot;math/tex&quot;&gt;\log(1 + \exp(b - a))&lt;/script&gt;. This method completely removes the &lt;script type=&quot;math/tex&quot;&gt;\exp&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\log&lt;/script&gt; calls in the inner loop of our HMM. After plugging Sean’s implementation into nanopolish we immediately had an 8-fold improvement in speed. Thanks to Sean for allowing us to use this as public domain code.&lt;/p&gt;

&lt;h2 id=&quot;improving-memory-layout&quot;&gt;Improving memory layout&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;perf&lt;/code&gt; output also indicated that a lot of CPU time was wasted waiting on memory access. To improve cache usage and reduce the amount of data that is transferred over the memory bus, I reduced the precision of the floating point values from 64 bits to 32 bits. At the same time, I changed the memory layout of the nanopore event signals so that data accessed together was located in contiguous memory locations. This change simply interleaved two arrays, one storing event currents and one storing event durations, into a single array of structs. Finally, I pre-computed all of the scalings and transformations that need to be applied to the nanopore events (for example the current signal drifts over time and this needs to be corrected for) to reduce the work in the inner loop of the HMM.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;This collection of changes reduced the average time spent in the forward algorithm of the HMM from &lt;script type=&quot;math/tex&quot;&gt;3,000 {\mu}s&lt;/script&gt; per call to &lt;script type=&quot;math/tex&quot;&gt;278 \mu s&lt;/script&gt; per call for 100 input events and a 100bp sequence, an improvment of over 10x. This did not require any changes at the algorithm level, only minor code optimizations. My next goal is to make algorithmic improvements, primarily avoiding testing unlikely candidate sequences in the HMM. Version 0.2.0 of nanopolish is &lt;a href=&quot;https://github.com/jts/nanopolish&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</content>
   </entry>
  
 

</feed>
